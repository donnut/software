#!/usr/bin/env python
# -*- mode: python; coding: utf-8 -*-
# Copyright © 2001, 2002, 2003, 2004, 2006, 2007 Translation Project.
# Copyright © 1998, 1999, 2000, 2001 Progiciels Bourbeau-Pinard inc.
# François Pinard <pinard@iro.umontreal.ca>, 1998.

"""\
Attempt automatic processing of PO file submissions.

Usage: tp-robot [-n] <MESSAGE

  -n   dry-run, do not send mails, do not change things
"""

required = [ "hylafax" ]

import os, sys, shutil, types, popen2
import re, string, quopri, datetime

sys.path.insert(0, sys.path[0]+'/../lib')
import config, po, registry, run, messages

# Find sendmail in /usr/sbin or /usr/lib.
os.environ['PATH'] = '/usr/lib:/usr/sbin:' + os.environ['PATH']

# Unset possible localisation.
try: del os.environ['LANGUAGE']
except KeyError:pass
try: del os.environ['LANG']
except KeyError:pass


def _qdecodestring(s):
    from cStringIO import StringIO
    infp = StringIO(s)
    outfp = StringIO()
    quopri.decode(infp, outfp)
    return outfp.getvalue()

def _(text):
#   return messages.MultiString(text)
    return text

class AbortRobot:
    pass

def abort_robot():
    raise AbortRobot

def main(*arguments):
    # Decode options.
    import getopt
    options, arguments = getopt.getopt(arguments, 'n')
    for (option, value) in options:
        if option == '-n':
            run.dry = 1
    if arguments:
        print "No arguments allowed: use standard input."
        sys.exit(2)
    # Do the processing.
    os.umask(002)
    run.hints = registry.hints()
    try:
        part = extract.submission()
        if part.name:
            extract.hints_from_name(part.name)
        if part.stack:
            check_mail.header()
        if part.work:
            extract.mail_body(part.work)  # Only used for coordinator reports.
            entries = po.read(part.work)
        else:
            entries = None
        if not entries:
            run.reject(_("""\
Your PO file seems to have no entries at all, like if it were empty.
"""), "[no entries]")
            abort_robot()
        # We definitely found a non-empty PO file.
        header = po.header(entries)
        check_po_file.header(header)
        check_registry.translator()
        archive_base = run.hints.archive_base()
        # First run 'msgfmt -c' on the original submission.
        check_po_file.contents(part.work, archive_base, "first")
        if check_registry.have_pot():
            process.make_canonical(part.work, archive_base, entries, header)
            # Then check that the merged file is okay too.
            check_po_file.contents(part.work, archive_base, "second")
        check_po_file.special_instructions(part.work)
        # The submission is acceptable, unless it is a duplicate.
        check_registry.preexisting(part.work)
        if run.rejected:
            abort_robot()
        process.congratulate()
        process.store_po_file(part.work)
    except AbortRobot:
        pass
    except:
        import traceback
        # Print the exception to get a message from cron.
        traceback.print_exc()
        tb = "".join(traceback.format_exception(*sys.exc_info()))
        run.reject(_("""\
The Translation Project robot failed in a rather unexpected way.
Please report all details at <coordinator@translationproject.org>.
"""), "[robot bug]")
        run.submitter.write_nofill(tb)
        run.coordinator.write_nofill(tb)
    # Push some feedback out, whatever happened.
    run.coordinator.complete()
    run.submitter.complete()


class globals:
    team_language = None                # language spoken by this team
    team_mailto = None                  # email address for the team
    team_mailtos = []                   # alternative email addresses
    reported_unknown = []               # to avoid reporting the same twice
    unknown_address_insert = _("""\
The Translation Project registry holds the preferred email address for all
translators, and where necessary some aliases as well.  But it is better to
avoid the proliferation of alternate email addresses and stick to only one,
whenever possible.  In any case, please keep the translation coordinator
informed of them.""")


class Extract:
    """\
Extracting information from the input.
"""

    def submission(self):
        """\
Return the message part that is most likely to contain the submission.
"""
        import unpack, tempfile
        # Read input into a file, as unpacking needs seekability.
        work = tempfile.mktemp()
        open(work, 'w').write(sys.stdin.read())
        parts = unpack.unpack_file(open(work))
        os.remove(work)
        if parts[0].stack:
            self.mail_header(parts[0].stack[-1])
        if len(parts) > 1:
            for part in parts[:]:
                if not part.name and part.size() < 1000:
#                    if part.work:
#                        run.submitter.write(_("""\
#I'm ignoring the whole following MIME part within your message:
#"""))
#                        run.submitter.write_nofill("""\
#---------------------------------------------------------------------->
#%s
#----------------------------------------------------------------------<
#"""
#                                               % open(part.work).read())
                    parts.remove(part)
        if len(parts) == 0:
            run.reject(_("""\
Hmm...  I cannot find a PO file within your email.  If you are certain
it is there, please report a robot bug to the coordinator.
"""), "[submission not found]")
            abort_robot()
        if len(parts) > 1:
            run.reject(_("""\
Your message contains multiple MIME parts, and I am unable to decide
which one holds your PO file.  Please help me and resubmit your message
with a simpler MIME structure.
"""), "[multiple submissions?]")
            abort_robot()
        return parts[0]

    def hints_from_name(self, input_name):
        try:
            run.hints.merge(input_name)
        except (KeyError, ValueError):
            # ValueError: merge did not find a matching regular expression.
            pass
        if run.hints.pot:
            run.reject(_("""\
The translation coordinator does not yet trust me enough to let me handle
a POT file all alone.  So, for this one, I'll go disturb him!
"""), "[robot does not support pot submission]")
            abort_robot()
        if not (run.hints.domain and run.hints.version and run.hints.team):
            run.reject(_("""\
%s
The file name argument should look like 'DOMAIN-VERSION.TEAM.po'
(all in lower case).
""")
                       % unknown_elements_comment(),
                       "[ill-formatted file name]")
            abort_robot()
        if not run.hints.team:
            run.reject(_("""\
Within the Translation Project, no team has the code '%s'.
""")
                       % run.hints.team, "[unknown team code]")
            abort_robot()
        globals.team_language = run.hints.team.language
        globals.team_mailto = (run.hints.team.mailto[0]
                               or run.translator_address)

    def mail_header(self, entity):
        # Save header with normalized field names.
        items = entity.items()
        items.sort()
        lines = []
        for field, value in items:
            lines.append('%s: %s\n'
                         % (string.join(map(string.capitalize,
                                            string.split(field, '-')),
                                        '-'),
                            value))
        # Seek for any useful information.
        to_user, to_site = None, None
        line_count = 0
        while 1:
            # Get next line.
            if lines:
                line = lines[0]
                del lines[0]
            else:
                line = None
            if not line or line[0] == '\n':
                break
            line_count = line_count + 1
            # Skip envelope.
            if line_count == 1:
                if re.match('From [^ ]+', line):
                    continue
            # Save line for diagnostics.
            run.header_lines.append(line)
            # Grind the line.
            match = re.match('From: +(.+?) +<(.+)>$', line)
            if match:
                run.translator_address = match.group(2)
                run.translator_name = mime_decode_header(match.group(1))
                continue
            match = re.match('From: +(.+?) +\((.+)\)$', line)
            if match:
                run.translator_address = match.group(1)
                run.translator_name = mime_decode_header(match.group(2))
                continue
            match = re.match('From: +([^ \n,<]+@[^ \n,>]+)$', line)
            if match:
                run.translator_address = match.group(1)
                continue
            match = re.match('To:.*?([^ \n,<]+)@([^ \n,>]+)', line, re.I)
            if match:
                to_user, to_site = match.group(1, 2)
                continue
            match = re.match('Subject:[ \t]+(.*)', line)
            if match:
                run.subject = match.group(1)
                try:
                    run.hints.merge(match.group(1))
                except (KeyError, ValueError):
                    pass
                else:
                    if run.hints.pot:
                        run.reject(_("""\
The translation coordinator does not trust me enough yet to let me handle
a PO template file all alone.  So, for this one, I'll go disturb him!
"""), "[pot not supported]")
                        abort_robot()
                continue
        # Check if the email was sent to a wrong address.
        if ((to_user and (to_user != 'robot') and (to_user !='translation'))
            or (to_site and (to_site !='translationproject.org'))):
            run.submitter.write(_("""\
Instead of using the old address <%s@%s> for PO file submissions,
please use my new address <robot@translationproject.org>.
""") % (to_user, to_site))
        # Clean up translator name.
        if run.translator_name:
            match = re.match('"(.+)"$', run.translator_name)
            if match:
                run.translator_name = match.group(1)

    def mail_body(self, where):
        run.body_lines = open(where).readlines()

extract = Extract()


########################### Verify submission details ##############
class CheckMail:
    """\
Validating mail specific information.
"""

    def header(self):
        if not run.translator_address:
            run.reject(_("""\
Cannot find a translator's email address in your submission.
"""), "[no email address]")
            abort_robot()
        if not (run.hints.domain and run.hints.version and run.hints.team):
            run.reject(_("""\
%s

As a reminder, the Subject line of your message should look like this:

    Subject: DOMAIN-VERSION.TEAM.po

DOMAIN is normally the package name, VERSION is the version number, and
TEAM is the two-letter language code for your team, all in lower case.
""")
                       % unknown_elements_comment(),
                       "[domain, version, or team is missing]")
            abort_robot()
        if run.hints.team:
            globals.team_language = run.hints.team.language
            globals.team_mailto = (run.hints.team.mailto[0]
                                   or run.translator_address)
            globals.team_mailtos = run.hints.team.mailto[:]
        else:
            run.reject(_("""\
Within the Translation Project, there is no team with the code '%s'.
If you simply mistyped the code, I invite you to correct the error
and retry the submission.

If however the code is correct, I presume you would like a new translation
team to be created.  This is a simple matter, really.  See
http://translationproject.org/leaders.html for all the details.
""")
                       % run.hints.team, "[unknown team]")
            globals.team_language = _('Unknown_Language')
            globals.team_mailto = run.translator_address

check_mail = CheckMail()


########################### Verify PO header and contents ##########
class CheckPoFile:
    """\
Validating the PO file.
"""

    def header(self, header):
        if run.translator_name:
            self.language_team(header)
            self.last_translator(header)
        else:
            self.last_translator(header)
            self.language_team(header)
        self.title(header)
        self.copyright(header)
        self.license(header)
        self.last_author(header)
        self.project_id_version(header)
        self.both_dates(header)
        self.mime_fields(header)

    def title(self, header):
        if not header['TITLE']:
            run.reject(_("""\
The PO title line seems to be missing.  The very first line of any PO
file should start with '# ' followed by a one-line description of what
the file is about.  The title line for this PO file could be:

    # Translation of '%s' messages to %s.
""") % (run.hints.domain, globals.team_language), "[no title header]")

    def copyright(self, header):
        text = header['COPYRIGHT']
        if isinstance(text, types.ListType):
            # Ignore other copyrights, just look at the first one.
            text = text[0]
        utext = po.decfunc(header)(text)[0]
        match = re.match('Copyright (\\(C\\)|\xa9|\xc2\xa9).* '
                         '(199[4-9]|200[0-7])(, ((19)?9[4-9]|(20)?0[0-7]))* '
                         '(?P<author>.*)', text)
        if match:
            # FIXME: Better validate year lists.
            author = 'Free Software Foundation, Inc.'
            definite_author = 0
            if run.hints.domain and run.hints.domain.potcopyright:
                definite_author = 1
                author = run.hints.domain.potcopyright
            if match.group('author') == author:
                return
            if run.hints.domain and \
               (run.hints.domain.disclaim or run.hints.domain.potcopyright):
                if not definite_author:
                    comment = _("""\
For the time being, I merely guess that the Free Software Foundation is to
be listed as the copyright holder for any package requiring translation
disclaimers.  Yet, the truth is that this requirement goes further than
the spirit of the disclaimer.  If this creates any problem in real life,
please write to the translation coordinator, so we can discuss the matter,
and so he could eventually change me (the robot) for handling such cases.
""")
                    reason = "[Copyright not FSF]"
                else:
                    comment = ""
                    reason = "[Copyright not %s]" % author
                run.reject(_("""\
The copyright for the PO file should be assigned to:

    %s

Maybe you didn't spell it right, or there is a superfluous period
at the end?  %s
""")
                           % (author, comment), reason)
        elif run.hints.domain and run.hints.domain.disclaim:
            if text:
                comment = (_("""\
The copyright comment is not fully correct:

    # %s

It should instead look like:
""")
                           % utext)
            else:
                comment = _("""\
The copyright line, which should appear as the second line of the whole
PO file, seems to be missing.  The copyright line should look like:
""")
            run.reject(_("""\
%s
    # Copyright (C) YEAR Free Software Foundation, Inc.

The YEAR should be either a single four-digit year, or a list of years
separated by commas, each comma followed by a space.  Years have to be
explicitly enumerated, range notations are not accepted.  The '(C)'
triplet (case matters) may be replaced with a single character if the
encoding of your file allows it: either the single Latin-1 byte
(decimal code 169) or the equivalent UTF-8 sequence (\\xc2\\xa9).
""") % comment, "[copyright incorrectly formatted]")

    def license(self, header):
        if not run.hints.domain.package:
            run.hints.domain.package = run.hints.domain.name
        flaw = False
        match = re.match('# This file is distributed under the same license'
                         ' as the (.*) package.', header['LICENSE'])
        if not header['LICENSE']:
            flaw = True
            run.submitter.write_nofill(_("""\
Your PO file does not seem to contain a comment line that specifies which
license covers the file.  Soon such a line will be required.  Consider
adding it right after the copyright line.  It should say exactly this:

# This file is distributed under the same license as the %s package.
""") % run.hints.domain.package)
        elif not match or match.group(1) != run.hints.domain.name:
            flaw = True
            run.submitter.write_nofill(_("""\
The license line is not fully correct:

%s

It should say exactly this:

# This file is distributed under the same license as the %s package.
""") % (header['LICENSE'], run.hints.domain.package))
        if flaw and (run.hints.domain.name in required):
            run.reject(_("""\
For %s the above license line is already mandatory.
""") % run.hints.domain.name)

    def last_author(self, header):
        match1 = re.search('.*; *(.*[^ ]) *<(.*)>.*?([0-9]*)$',
                          header['AUTHORS'])
        match2 = re.search('.*; ([^ ].+[^ ]) <([^ ]+)>, .*(199[4-9]|200[0-9])$',
                          header['AUTHORS'])
        if not match1:
            run.reject(_("""\
There is no author comment line in your PO file, or it is not formatted
correctly.  Author lines should come after the copyright lines, and look
like this:

    # NAME OF AUTHOR <EMAIL@ADDRESS>, YEAR.

There may be several of these lines, normally in chronological order.
"""), "[missing or ill-formatted author line]")
            run.submitter.write(_("""\
If you wish to add some general comments to the PO file, you can put them
after the title, copyright, and author lines.  There should be a space
after the '#' that starts each comment line, and no blank line before
the very first 'msgid' (the empty one).
"""))
            return
        if ((match1 and not match2) or
            (match1.group(1, 2, 3) != match2.group(1, 2, 3))):
            run.submitter.write(_("""\
There is a slight formatting error in one of the author lines:
superfluous spaces, no name, a lacking comma, or a bad year.
"""))
        last_name, last_address, last_year = match1.group(1, 2, 3)
        last_name = po.decfunc(header)(last_name)[0]
        try:
            translator = registry.translator(run.hints.team,
                                             last_name, last_address)
        except KeyError:
            return
        if last_name != run.translator_name:
            run.submitter.write(_("""\
The last name in the author lines differs from the name in the PO file
header.  The last of the author lines mentions '%s', while the
'Last-Translator' field says '%s'.  Maybe the author lines are in the
wrong order?  The expected order is chronological: the earliest
translator first, and your own author line last.
""")
                                % (last_name, run.translator_name))
        elif last_address != run.translator_address:
            run.submitter.write(_("""\
Your submission contains contradicting addresses for you.  The last of the
introductory author lines says <%s>, while the 'Last-Translator' field of
the PO file header says <%s>.  Please arrange to have a single preferred
address to reach you, and use it consistently in all your translation files.
""")
                                % (last_address, run.translator_address))
        elif last_year != datetime.date.today().strftime('%Y'):
            run.submitter.write(_("""\
The final year (%s) given in the last author line (which should be yours)
is not the current year.  Please correct either the year or the order of
the author lines: the earliest author first, the latest last.
""")
                                % last_year)

    def project_id_version(self, header):
        match = re.search('(Free |GNU )?(?P<dom>%s)(?P<sep>[- ])(?P<ver>%s)' %
                          (registry.DOMAIN, registry.VERSION),
                          header['project-id-version'])
        if match:
            if match.group('dom') != run.hints.domain.name:
                run.reject(_("""\
The 'Project-Id-Version' field of your PO file says that the textual domain
is '%s', instead of '%s' as the file name says.  They should be the same. 
The domain name is usually just the package name, in all lower case.
""")
                           % (match.group('dom'), run.hints.domain),
                           "[domain in project-id conflicts with file name]")
            if match.group('sep') == '-':
                # Silently replace a hyphen with a space.
                header['project-id-version'] = (
                    header['project-id-version'][:match.start('ver')] + ' '
                    + header['project-id-version'][match.end('ver'):])
            if match.group('ver') != run.hints.version.name:
                run.reject(_("""\
The 'Project-Id-Version' field of your PO file says the translation
is meant for version '%s' of '%s', but the file name says it is for
version '%s'.  Please adjust either the 'Project-Id-Version' field or
the file name, whichever is appropriate.
""")
                           % (match.group('ver'), run.hints.domain.name,
                              run.hints.version.name),
                           "[version in project-id conflicts with file name]")
        else:
            run.reject(_("""\
The 'Project-Id-Version' field was not found in your PO file header.
The line containing this field ideally looks like:

    "Project-Id-Version: PACKAGE VERSION\\n"

in which PACKAGE should be replaced by the textual domain of your
translation, probably '%s' in this case, and VERSION be replaced
by the appropriate version numbers, maybe '%s' here.
""")
                       % (run.hints.domain.name, run.hints.version.name),
                       "[no project-id-version]")

    def both_dates(self, header):
        date = {}
        for field in 'POT-Creation-Date', 'PO-Revision-Date':
            value = header[string.lower(field)]
            match = re.match('(199[4-9]|200[0-7])-[01][0-9]-[0-3][0-9] '
                             '[0-2][0-9]:[0-5][0-9]( ?[-+][0-1][0-9](:?00)?)?',
                             value)
            if match:
                date[field] = value
            elif field == 'POT-Creation-Date':
                run.submitter.write(_("""\
The 'POT-Creation-Date' field is missing from your PO file header, or
misformatted.  I will copy the original line from the POT file.
"""))
            else:
                run.reject(_("""\
The 'PO-Revision-Date' field was not found in your PO file header, or
was not formatted properly.  The line containing it should look like:

    "PO-Revision-Date: YEAR-MO-DA HO:MI +ZONE\\n"
"""), "[missing revision date]")
                run.submitter.write(_("""\
In the above line, YEAR is a four-digit number giving the year,
MO is a two-digit number giving the month (from 01 to 12), and DA
is a two-digit number giving the day within the month (from 01 to 31).
The time of day is provided by a two-digit HO for the hour (from
00 to 23) and a two-digit MI for the minutes (from 00 to 59).

As for +ZONE, it should have the format +HH, -HH, +HH:MM, or -HH:MM.
The '+' sign is used east of Greenwich, the '-' sign west of Greenwich.
HH gives the number of zone hours as two digits (from 00 to 11), while MM,
when used, gives the number of zone minutes.  Other zone notations are
still accepted for the time being, but are to be deprecated.
"""))
        if ('POT-Creation-Date' in date and 'PO-Revision-Date' in date):
            if date['PO-Revision-Date'] <= date['POT-Creation-Date']:
                run.reject(_("""\
The PO revision date is '%s', which is older than the POT creation date,
'%s'.  Please update the revision date field before submitting a PO file.
""")
                           % (date['PO-Revision-Date'],
                              date['POT-Creation-Date']),
                           "[revision date before creation date]")

    def last_translator(self, header):
        text = header['last-translator']
        match = re.match('(.*?)( +)<(.+)>$', text)
        if match:
            last_translator, last_address = match.group(1, 3)
            last_translator = po.decfunc(header)(last_translator)[0]
            if len(match.group(2)) != 1:
                run.submitter.write(_("""\
There is a slight formatting error.  In the 'Last-Translator' header line,
please use no more than a single space between '%s' and '<%s>'.
""")
                                    % (last_translator, last_address))
            if not run.translator_name:
                run.translator_name = last_translator
            if not run.translator_address:
                run.translator_address = last_address
            try:
                translator = registry.translator(run.hints.team,
                                                 last_translator, last_address)
            except KeyError:
                run.reject(_("""\
According to my notes, %s is not a member of the %s team.  If this is only
a matter of spelling, then I need to know about the alternatives, so please
tell the translation coordinator about these.  It is, however, usually best
to avoid such variance, and stick to a single preferred spelling.

It may also be that you never joined the %s team.  Please write to the leader
of your team (see %s/team/%s.html), or else to the translation coordinator.
""")
                           % (last_translator,
                              _(globals.team_language),
                              _(globals.team_language),
                              config.site_base, run.hints.team.code),
                           "[translator not in team]")
                abort_robot()
            if last_address not in translator.mailto:
                if last_address not in globals.reported_unknown:
                    run.reject(_("""\
The last translator of this PO file is %s.  But according to my notes,
<%s> is not a good address to reach that translator.  %s %s
""")
                               % (last_translator, last_address,
                                  say_alias_list(translator.mailto),
                                  globals.unknown_address_insert),
                               "[last address unknown]")
                    globals.reported_unknown.append(last_address)
                    globals.unknown_address_insert = ''
                return
            if last_translator != run.translator_name:
                run.submitter.write(_("""\
I'm not fully sure that you are the author of the translations you
sent me.  The header of your email says that you are '%s', while the
'Last-Translator' field of the PO file header says your name is '%s'. 
The difference might be a mere spelling difference.  This can happen
when you do not have full control over your name in the mailing system
you are using.

As I expect you have better control over PO files, I'll consider that
the second name is the most dependable.  Yet, in some cases, this might
represent an error I am unable to analyse, while you do.  In the unlikely
case that the two names above are really different, the situation is more
serious.  Some translation teams surely have their own ways and habits,
but it is unusual that someone submits a translation file written by
someone else.
""")
                                    % (run.translator_name, last_translator))
            elif last_address != run.translator_address:
                run.submitter.write(_("""\
Your message was sent from '%s', but the 'Last-Translator' field in the
PO file says that your email address is '%s'.  I assume that the latter
is correct -- I bring this to your attention just in case _you_ think it
matters.
""")
                                    % (run.translator_address, last_address))
            run.translator_name = last_translator
            run.translator_address = last_address
        else:
            run.reject(_("""\
The 'Last-Translator' field was not found in your PO file header, or
is not formatted properly.  The line containing it should look like:

    "Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n"

In this line, FULL NAME has to be replaced by the full name of the current
translator for the '%s' textual domain (which most probably means you :-);
EMAIL@ADDRESS gives a way to reach that translator by email.
""")
                       % run.hints.domain, "[last-translator missing]")

    def language_team(self, header):
        text = header['language-team']
        match = re.match('(.*?)( *)<(.+)>$', text)
        if match:
            maybe_language, maybe_mailto = match.group(1, 3)
            try:
                maybe_language.decode('ascii')  # language name should be ASCII
            except UnicodeError:
                m = []
                for c in maybe_language:
                    if ord(c) < 128: m.append(c)
                    else: m.append('\\%2x' % ord(c))
                maybe_language = ''.join(m)
            if len(match.group(2)) > 1:
                run.submitter.write(_("""\
There is a slight formatting error.  In the 'Language-Team' header line,
please use no more than a single space between '%s' and '<%s>'.
""")
                                    % (maybe_language, maybe_mailto))
            if maybe_language != globals.team_language:
                run.reject(_("""\
You wrote '%s' in the 'Language-Team' field of the PO file header, while
I think it should have been '%s'.  If I am wrong, please email the
translation coordinator to get this straightened out.
""")
                           % (maybe_language, _(globals.team_language)),
                           "[language-team incorrect]")
            if not globals.team_mailto:
                run.reject(_("""\
Each translation team should publish some mailing list address, meant
to appear (between angular brackets) after the language name in the
'Language-Team' field of the PO file header.  The Translation Project
does not have such an address for the %s team.  You might already know
some list dedicated to internationalisation efforts for %s, which may
fit your needs.  In case you know none, waiting to get better organised,
you might use the address of one of the team members, maybe yours if you
are alone in the team!  In any case, please inform the translation
coordinator of the address your team decides to use.
""")
                           % (_(globals.team_language),
                              _(globals.team_language)),
                           "[team address missing]")
            elif maybe_mailto != globals.team_mailto and \
                     maybe_mailto not in globals.team_mailtos:
                run.reject(_("""\
The 'Language-Team' field of the PO file header contains <%s> as the team's
email adress, but the registered team's address is <%s>.  If the latter is
wrong, please email the translation coordinator to get it corrected.
""")
                           % (maybe_mailto, globals.team_mailto),
                           "[team address incorrect]")
        else:
            run.reject(_("""\
The 'Language-Team' field was not found in your PO file header, or is
not formatted correctly.  The line containing it should look like:

    "Language-Team: LANGUAGE <TEAM-EMAIL-ADDRESS>\\n"

In this line, LANGUAGE is the English name of your language, capitalizing
the first letter of its words and leaving the rest in lower case.
In several cases the TEAM-EMAIL-ADDRESS takes the form of
'translation-team-TEAM@lists.sourceforge.net', where TEAM is the ISO-639
code for your language (not to be confused with country codes, which are
a different standard).  If I had to write this line myself, right now,
according to the information which is available to me, I would use:

    "Language-Team: %s <%s>\\n"
""")
                       % (globals.team_language, globals.team_mailto),
                       "[language team missing]")

    def mime_fields(self, header):
        if header['mime-version'] != '1.0':
            run.reject(_("""\
The 'MIME-Version' field was not found in your PO file header, or is
not formatted properly.  The line should be this one:

    "MIME-Version: 1.0\\n"
"""),
                       "[mime-version is not 1.0]")
        charsets = [
            'us-ascii',
            'ISO-8859-1',
            'ISO-8859-2',
            'ISO-8859-3',
            'ISO-8859-7',
            'ISO-8859-8',
            'ISO-8859-9',
            'ISO-8859-13',
            'ISO-8859-15',
            'koi8-r',
            'koi8-u',
            'EUC-KR', 'big5', 'big5-hkscs',
            'ISO-2022-JP', 'EUC-JP',
            'gb2312', 'gb18030',
            'UTF-8',
            ]
        match = re.match('text/plain; charset=(.*)', header['content-type'])
        if match:
            charset = match.group(1)
            if string.lower(charset) not in map(string.lower, charsets):
                run.reject(_("""\
The 'Content-Type' field introduced an unusual character set '%s'.
If this is not an error, please merely inform the translation coordinator
that '%s' be added to the list of acceptable charsets.
This list currently holds: %s.
""")
                           % (charset, charset, say_list(_('or'), charsets)),
                           "[unknown charset in content-type]")
            run.po_charset = charset
        else:
            run.reject(_("""\
The 'Content-Type' field was not found in your PO file header, or is
not formatted properly.  The line containing it ideally looks like:

    "Content-Type: text/plain; charset=CHARSET\\n"

where CHARSET should be the name of a character set, like one of %s.
""")
                       % say_list(_('or'), charsets),
                       "[content-type missing or ill-formatted]")
        encodings = ['8-bit', '8bit', 'Base64']
        cte = header['content-transfer-encoding']
        if cte:
            if cte not in encodings:        # FIXME: ignore case
                run.reject(_("""\
The 'Content-Transfer-Encoding' field introduced an unusual encoding
'%s'.  If this is not an error, please inform the translation
coordinator that '%s' be added to the list of acceptable charsets.
This list currently holds: %s.
""")
                           % (cte, cte, say_list(_('and'), encodings)),
                           "[unknown content-transfer-encoding]")
        else:
            run.reject(_("""\
The 'Content-Transfer-Encoding' field was not found in your PO file header,
or is not formatted properly.  The line containing it ideally looks like:

    "Content-Transfer-Encoding: ENCODING\\n"

where ENCODING should be the name of an encoding, like one of %s.
""")
                       % say_list(_('or'), encodings),
                       "[content-transfer-encoding missing]")

    def scan_gettext_output(self, lines, work, virtual):
        comment = []
        for line in lines:
            if re.match('[0-9]+ translated messages\.$', line):
                continue
            if line[:len(work)] == work:
                line = virtual + line[len(work):]
            comment.append('> %s' % line)
        return comment

    def contents(self, work, virtual, cycle):
        try:
            cmd = 'msgfmt -cv -o /dev/null %s'
            proc = popen2.Popen3(cmd % work, 1)
            lines = proc.childerr.readlines()
            reject = proc.wait()
        except:
            run.reject(_("""\
I am unable to run the 'msgfmt' program.  Sorry.  Something needs
to be fixed here.  I'll go warn the translation coordinator.
"""), "[msgfmt failed]")
            abort_robot()
        comment = self.scan_gettext_output(lines, work, virtual)
        if reject:
            run.reject_nofill(_("""\
As a last check, I ran 'msgfmt -cv -o /dev/null' on your PO file.  It
told me that I cannot let the file pass.  It reported these errors:
%s""") % ('').join(comment), "[msgfmt errors]")
            abort_robot()
        if comment and (cycle == "first"):
            run.submitter.write_nofill(_("""\
Merely for your information, let me share with you what the
'msgfmt' program has to say about your PO file:
%s""") % ('').join(comment))
            # Try extracting the translated, fuzzy, and untranslated numbers.
            match = re.match('> ([0-9]+) .*?([0-9]+) .*?([0-9]*)', comment[0])
            if match:
                done = eval(match.group(1))
                left = eval(match.group(2)) + (eval(match.group(3)+'0') / 10)
                if done < left:
                    run.reject(_("""\
The number of translated strings is less than half of the total number
of strings.  Please translate more before submitting a file.
"""), "[too few translations]")
                    abort_robot()

    def special_instructions(self, work):
        if run.hints.domain.name == 'util-linux':
            contents = open(work, 'r').read()
            if contents.find('Permission is granted to freely copy and distribute') == -1:
                run.submitter.write(_("""\
At first sight it seems your translation does not contain a clause that
permits redistribution.  Please consider inserting a sentence like
"""))
                run.submitter.write_nofill("""\
# Permission is granted to freely copy and distribute
# this file and modified versions, provided that this
# header is not removed and modified versions are marked
# as such.
""")
                
check_po_file = CheckPoFile()


########################### Verify submitter and existence #########
class CheckRegistry:
    """\
Comparing data of the submission with data in the TP registry.
"""

    def translator(self):
        team_found = translator_found = domain_found = 0
        try:
            translator = registry.translator(run.hints.team,
                                             run.translator_name,
                                             run.translator_address)
        except KeyError:
            run.reject(_("""\
According to my notes, you are not a member of the %s team. Or at least,
you are not listed there under the name '%s'.  If this is only a matter
of spelling differences, then I need to know exactly which alternate
spellings of your name you use.  Write to the translation coordinator
and explain why you need several different names.  But it is usually
best to avoid such variance, and stick to a single preferred spelling.
""")
                       % (_(globals.team_language), run.translator_name),
                       "[translator not found]")
            return
        if run.translator_address not in translator.mailto:
            if run.translator_address not in globals.reported_unknown:
                run.reject(_("""\
According to my notes, the address <%s> is not a valid way to reach you. 
%s %s
""")
                           % (run.translator_address,
                              say_alias_list(translator.mailto),
                              globals.unknown_address_insert),
                           "[translator address not in registry]")
                globals.reported_unknown.append(run.translator_address)
                globals.unknown_address_insert = ''
        if not run.hints.domain:
            run.reject(_("""\
The '%s' textual domain is not known to the Translation Project, at
least not under that spelling.  It may also be that the maintainer of
that project did not make arrangements yet for the Translation Project to
handle its PO files.  In this case, please invite the project maintainer to
contact us.  See http://translationproject.org/domain/index.html
for the list of domains that are currently handled.
""")
                       % run.hints.domain,
                       "[unknown domain]")
        ok, reason = self.translator_can_submit(translator, run.hints.domain)
        if ok:
            if run.hints.domain.disclaim and not translator.disclaimer:
                run.reject(_("""\
According to my notes, the Free Software Foundation did not acknowledge the
receipt of a translation disclaimer for you.  Such a disclaimer is required
for '%s'.  See http://translationproject.org/html/whydisclaim.html for an
explanantion of this.
""")
                           % run.hints.domain,
                           "[translator has no disclaimer]")
        else:
            run.reject(_("""\
You are not registered as the usual translator for '%s': %s.  If you wish
to be assigned to this textual domain, your team leader may send an email
to the translation coordinator warranting that you are indeed assigned.
""")
                       % (run.hints.domain, reason[1:-1]), reason)

    def have_pot(self):
        if not os.path.isfile(run.hints.template_path()):
            run.reject(_("""\
You submitted a PO file for which the Translation Project does not have a
corresponding template: there is no '%s' here.
Please have the maintainer of the package send the corresponding POT file
to the Translation Project.  Or better: a URL of a distribution tarball.
""")
                       % run.hints.template_base(),
                       "[there is no corresponding pot file]")
            return 0
        return 1

    def preexisting(self, work):
        if registry.compare_files(work, run.hints.archive_path()):
            comment = [_("""
The Translation Project already holds an exact copy of your submission,
which you may find as:
""")]
            comment.append('    %s\n' % run.hints.archive_url())
            run.reject_nofill(('').join(comment), "[duplicate submission]")

    def translator_can_submit(self, translator, domain):
        # If it is the assigned translator, accept.
        if domain in translator.do:
            return 1, "[translator is assigned]"
        # If it is the team leader, accept.    
        if translator.name == run.hints.team.leader.name:
            return 1, "[team leader can upload any domain]"
        # If somebody else is assigned, reject.
        if run.hints.team.translator_for_domain(domain):
            return 0, "[someone else is assigned to this domain]"
        # If there is an external translation, reject.
        if run.hints.team.code in domain.ext:
            return 0, "[the domain is externally translated]"
        # If there is no preexisting translation, accept.
        #! This checking of a symlink is not foolproof, as there are some files
        #! for which this symlink is missing or pointing to an old version.
        file = run.hints.maintainer_path()
        if not os.path.exists(file):
            return 1, "[first submission to this domain]"
        # If it exists, find its submitter, the "last maker".
        import data
        stats = data.load_postats()
        hints = registry.Hints(os.readlink(file))
        try:
            st = stats[(hints.domain.name, hints.version.name, hints.team.name)]
            last_maker, email = st[0], st[1]
        except KeyError:
            # Stats not updated yet, need to read PO file.
            content = po.read(file)
            last_maker, email = po.last_translator(po.header(content))
        try:
            last_maker = registry.translator(hints.team, last_maker, email)
        except KeyError:
            return 0, "[unknown translator]"
        # If the current submitter equals the last maker, accept.
        if translator == last_maker:
            return 1, "[translator equals last translator]"
        else:
            return 0, "[someone else made the last submission]"

check_registry = CheckRegistry()


########################### Canonicalize and store #################
class Process:
    """\
Accomplishing some actions.
"""

    def make_canonical(self, where, virtual, entries, header):
        os.system('recode -f /cl <%s | msgmerge -q --no-wrap - %s >%s.norm'
                  % (where, run.hints.template_path(), where))
        try:
            lines = os.popen('recode -f /cl <%s | diff -u -L %s~ -L %s - %s.norm'
                             % (where, virtual, virtual, where)).readlines()
        except:
            run.reject(_("""\
I am unable to run the 'diff' program.  Sorry.  Something needs
to be fixed here.  I'll go warn the translation coordinator.
"""), "[diff or recode failed]")
            abort_robot()
        # FIXME: Maybe detect and better explain `msgid' reformatting, trailing
        # space elimination, and other less evident matters.
        try:
            os.remove(where)
            os.rename('%s.norm' % where, where)
        except:
            run.reject(_("""\
I am unable to canonicalise your PO file.  Sorry.  Something needs
to be fixed here.  I'll go warn the translation coordinator.
"""), "[remove or rename failed]")
            abort_robot()
        if lines:
            if len(lines) > 50:
                lines = lines[:50] + ["[truncated]\n"]
            run.submitter.write(_("""\
The Translation Project is trying to reach a consistent presentation for
PO files, over all domains and languages.  Your submission was not fully
canonical, so the robot has made the following modifications to your PO
file.  You can use 'patch' to apply these changes to your local file,
but you do not need to: the robot will continue making them patiently and
automatically here.  This message continues after the (maybe long) diff.
"""))
            # Possibly non-ASCII byte strings, don't try to translate.
            run.submitter.write_nofill("""\
---------------------------------------------------------------------->
%s----------------------------------------------------------------------<
"""
                                  % ''.join(lines))

    def congratulate(self):
        run.subject = 'TP: %s [ACCEPTED]' % run.shorten(run.subject)
        run.submitter.write(_("""\
Your file has been accepted and stored in the archives.  Thank you!
"""))
#When the maintainer of '%s' submits a new POT file to the Translation
#Project, the translation you just made will probably need revision.  Your
#team will then be notified of the URL of the PO file to revise, together
#with a quick evaluation of the extent of the work needed.
#                            % run.hints.domain.name)
        try:
            translator = registry.translator(run.hints.team,
                                             run.translator_name,
                                             run.translator_address)
        except KeyError:
            pass
        else:
            if not translator.autosend:
                run.submitter.write(_("""\
If you wish, I can email you an updated copy of this PO file whenever
a new template file for it is registered at the TP.  If you want this
service for yourself, ask the translation coordinator.
"""))

    def store_po_file(self, work_name):
        archive_base = run.hints.archive_base()
        incoming = '%s/%s' % (config.temp_path, archive_base)
        # Remove any file left over from a previous try in dry mode.
        if os.path.isfile(incoming):
            os.remove(incoming)
        shutil.move(work_name, incoming)
        try:
            if run.dry:
                dry_flag = '-n'
            else:
                dry_flag = ''
            lines = os.popen(
                'cd %s && %s/bin/po-register %s %s 2>&1'
                % (config.temp_path, config.progs_path, dry_flag, archive_base)
                ).readlines()
        except:
            run.reject(_("""\
I am unable to run the 'po-register' program.  Sorry.  Something needs
to be fixed here.  I'll go warn the translation coordinator.
"""), "[po-register failed]")
            return
        comment = []
        write = comment.append
        if run.header_lines:
            write(_("Original message header:\n\n"))
            for line in run.header_lines:
                write('>    ' + line)
        write(_("\nDiagnostics issued by 'po-register':\n\n"))
        for line in lines:
            write('>    ' + line)
        write(_("\nIf something needs changing, write to:\n"))
        write(_(" <coordinator@translationproject.org>\n"))
        run.coordinator.write_nofill(('').join(comment))

process = Process()


## Diagnostics.

def unknown_elements_comment():
    known = []
    unknown = []
    if run.hints.domain:
        known.append(_("the domain name is '%s'") % run.hints.domain)
    else:
        unknown.append(_("the domain name"))
    if run.hints.version:
        known.append(_("the version number is '%s'") % run.hints.version)
    else:
        unknown.append(_("the version number"))
    if run.hints.team:
        known.append(_("the team code is '%s'") % run.hints.team)
    else:
        unknown.append(_("the team code"))
    if known:
        return (_("Some information is missing in your message header: %s."
                "  I did find that %s.")
                % (say_list(_('and'), unknown), say_list(_('and'), known)))
    return (_("Information that is missing in your message header: %s.")
            % say_list(_('and'), unknown))

def say_alias_list(items):
    if len(items) == 0:
        return _("""\
No official email address is registered for this translator.
""")
    if len(items) == 1:
        return (_("""\
The only registered address for this translator is <%s>.
""")
                % items[0])
    aliases = items[:]
    aliases.sort()
    return (_("""\
The only registered addresses for this translator are: %s.
""")
            % say_list(_('and'), aliases))

def say_list(word, items):
    if len(items) == 0:
        return 'none'
    if len(items) == 1:
        return items[0]
    return '%s %s %s' % ((', ').join(items[:-1]), word, items[-1])


ecre = re.compile(r'''
  =\?                   # literal =?
  (?P<charset>[^?]*?)   # non-greedy up to the next ? is the charset
  \?                    # literal ?
  (?P<encoding>[qb])    # either a "q" or a "b", case insensitive
  \?                    # literal ?
  (?P<atom>.*?)         # non-greedy up to the next ?= is the atom
  \?=                   # literal ?=
  ''', re.VERBOSE | re.IGNORECASE)

## Taken from email.Utils.decode.
def mime_decode_header(h):
    rtn = []
    parts = ecre.split(h, 1)
    while parts:
        # If there are less than 4 parts, it can't be encoded and we're done.
        if len(parts) < 5:
            rtn.extend(parts)
            break
        # The first element is any non-encoded leading text.
        rtn.append(parts[0])
        charset = parts[1]
        encoding = parts[2].lower()
        atom = parts[3].replace('_', ' ')
        # The next chunk to decode should be in parts[4].
        parts = ecre.split(parts[4])
        # The encoding must be either 'q' or 'b', case-insensitive.
        if encoding == 'q':
            func = _qdecodestring
        else:
            # XXX base64 not supported.
            return h
        try:
            # Decode and get the unicode in the charset.
            rtn.append(unicode(func(atom), charset))
        except:
            return h
    # Now that we've decoded everything, we just need to join all the parts
    # together into the final string.
    try:
        return u"".join(rtn)
    except UnicodeError:
        # Some of the ASCII parts contain characters above 128;
        # assume they are Latin-1.
        for i in range(len(rtn)):
            if type(rtn[i])==types.StringType:
                rtn[i] = unicode(rtn[i], "iso-8859-1")
        return u"".join(rtn)

if __name__ == '__main__':
    apply(main, tuple(sys.argv[1:]))
    #try:
    #    apply(main, tuple(sys.argv[1:]))
    #except AbortRobot:
    #    sys.exit(1)
