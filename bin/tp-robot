#!/usr/bin/env python
# -*- mode: python; coding: utf-8 -*-
# Copyright © 2001, 2002, 2003, 2004, 2006, 2007 Translation Project.
# Copyright © 1998, 1999, 2000, 2001 Progiciels Bourbeau-Pinard inc.
# François Pinard <pinard@iro.umontreal.ca>, 1998.

"""\
Attempt automatic processing of PO file submissions.

Usage: tp-robot [-n] <MESSAGE

  -n   dry-run, do not send mails, do not change things
"""

import os, sys, shutil, types, popen2
import re, string, quopri

sys.path.insert(0, sys.path[0]+'/../lib')
import config, po, registry, run, messages

# Find sendmail in /usr/sbin or /usr/lib.
os.environ['PATH'] = '/usr/lib:/usr/sbin:' + os.environ['PATH']

# Unset possible localisation.
try: del os.environ['LANGUAGE']
except KeyError:pass
try: del os.environ['LANG']
except KeyError:pass


def _qdecodestring(s):
    from cStringIO import StringIO
    infp = StringIO(s)
    outfp = StringIO()
    quopri.decode(infp, outfp)
    return outfp.getvalue()

def _(text):
#   return messages.MultiString(text)
    return text

class AbortRobot:
    pass

def abort_robot():
    raise AbortRobot

def main(*arguments):
    # Decode options.
    import getopt
    options, arguments = getopt.getopt(arguments, 'n')
    for (option, value) in options:
        if option == '-n':
            run.dry = 1
    if arguments:
        print "No arguments allowed: use standard input."
        sys.exit(2)
    # Do the processing.
    os.umask(002)
    run.hints = registry.hints()
    try:
        part = extract.submission()
        if part.name:
            extract.hints_from_name(part.name)
        if part.stack:
            check_mail.header()
        if part.work:
            # This is only useful for coordinator reports, currently.
            extract.mail_body(part.work)
            entries = po.read(part.work)
        else:
            entries = None
        if not entries:
            run.reject(_("""\
Your PO file seems to have no entries at all, like if it were empty.
"""), "[no entries]")
            abort_robot()
        # We definitely found a non-empty PO file.
        header = po.header(entries)
        check_po_file.header(header)
        check_registry.translator()
        have_pot = check_registry.have_pot()
        archive_base = run.hints.archive_base()
        # Run 'msgfmt -c' on the original submission.
        check_po_file.contents(part.work, archive_base, "first")
        if have_pot:
            process.make_canonical(part.work, archive_base, entries, header)
            # Then check that the merged file is okay too.
            check_po_file.contents(part.work, archive_base, "second")
        check_po_file.special_instructions(part.work)
        # The submission is acceptable, unless it is a duplicate.
        check_registry.preexisting(part.work)
        if run.rejected:
            abort_robot()
        process.congratulate()
        process.upload_po_file(part.work)
    except AbortRobot:
        pass
    except:
        import traceback
        # Print the exception to get a message from cron.
        traceback.print_exc()
        tb = "".join(traceback.format_exception(*sys.exc_info()))
        run.reject(_("""\
The Translation Project robot failed in a rather unexpected way.
Please report all details at <coordinator@translationproject.org>.
"""), "[robot bug]")
        run.submitter.write_nofill(tb)
        run.coordinator.write_nofill(tb)
    # Push some feedback out, whatever happened.
    run.coordinator.complete()
    run.submitter.complete()

class globals:
    team_language = None                # language spoken by this team
    team_mailto = None                  # email address for the team
    team_mailtos = []                   # alternative email addresses
    reported_unknown = []               # to avoid reporting the same twice
    unknown_address_insert = _("""\
The Translation Project registry holds the preferred email address for all
translators, and where necessary some aliases as well.  But it is better to
avoid the proliferation of alternate email addresses and stick to only one,
whenever possible.  In any case, please keep the translation coordinator
informed of them.""")


class Extract:
    """\
Extracting information from the input.
"""

    def submission(self):
        """\
Return the message part that is most likely to contain the submission.
"""
        import unpack, tempfile
        # Read input into a file, as unpacking needs seekability.
        work = tempfile.mktemp()
        open(work, 'w').write(sys.stdin.read())
        parts = unpack.unpack_file(open(work))
        os.remove(work)
        if parts[0].stack:
            self.mail_header(parts[0].stack[-1])
        if len(parts) > 1:
            for part in parts[:]:
                if not part.name and part.size() < 1000:
                    if part.work:
                        run.submitter.write(_("""\
I'm ignoring the whole following MIME part within your message:
"""))
                        run.submitter.write_nofill("""\
---------------------------------------------------------------------->
%s
----------------------------------------------------------------------<
"""
                                               % open(part.work).read())
                    parts.remove(part)
        if len(parts) == 0:
            run.reject(_("""\
Hmm...  It seems I'm not clever enough yet to find the PO file within
your email.  I will go ask the coordinator to help me unpack your mail.
"""), "[submission not found]")
            abort_robot()
        if len(parts) > 1:
            run.reject(_("""\
Your message contains multiple MIME parts, and I am unable to decide
which one is meant to hold your PO file.  Please help me and resubmit
your message with a simpler MIME structure.
"""), "[multiple submissions?]")
            abort_robot()
        return parts[0]

    def hints_from_name(self, input_name):
        try:
            run.hints.merge(input_name)
        except (KeyError, ValueError):
            # ValueError: merge did not find a matching regular expression.
            pass
        if run.hints.pot:
            run.reject(_("""\
The translation coordinator does not yet trust me enough to let me handle
a POT file all alone.  So, for this one, I'll go disturb him!
"""), "[robot does not support pot submission]")
            abort_robot()
        if not (run.hints.domain and run.hints.version and run.hints.team):
            run.reject(_("""\
%s
The file name argument should look like 'DOMAIN-VERSION.TEAM.po'.
""")
                       % unknown_elements_comment(),
                       "[ill-formatted file name]")
            abort_robot()
        if not run.hints.team:
            run.reject(_("""\
Within the Translation Project, no team has the code '%s'.
""")
                       % run.hints.team, "[unknown team code]")
            abort_robot()
        globals.team_language = run.hints.team.language
        globals.team_mailto = (run.hints.team.mailto[0]
                               or run.translator_address)

    def mail_header(self, entity):
        # Save header with normalized field names.
        items = entity.items()
        items.sort()
        lines = []
        for field, value in items:
            lines.append('%s: %s\n'
                         % (string.join(map(string.capitalize,
                                            string.split(field, '-')),
                                        '-'),
                            value))
        # Seek for any useful information.
        to_user, to_site = None, None
        line_count = 0
        while 1:
            # Get next line.
            if lines:
                line = lines[0]
                del lines[0]
            else:
                line = None
            if not line or line[0] == '\n':
                break
            line_count = line_count + 1
            # Skip envelope.
            if line_count == 1:
                if re.match('From [^ ]+', line):
                    continue
            # Save line for diagnostics.
            run.header_lines.append(line)
            # Grind the line.
            match = re.match('From: +(.+?) +<(.+)>$', line)
            if match:
                run.translator_address = match.group(2)
                run.translator_name = mime_decode_header(match.group(1))
                continue
            match = re.match('From: +(.+?) +\((.+)\)$', line)
            if match:
                run.translator_address = match.group(1)
                run.translator_name = mime_decode_header(match.group(2))
                continue
            match = re.match('From: +([^ ]+)$', line)
            if match:
                run.translator_address = match.group(1)
                continue
            match = re.match('To:.*([^ \n,<]*)@([^ \n,>]+)', line, re.I)
            if match:
                to_user, to_site = match.group(1, 2)
                continue
            match = re.match('Subject:[ \t]+(.*)', line)
            if match:
                run.subject = match.group(1)
                try:
                    run.hints.merge(match.group(1))
                except (KeyError, ValueError):
                    pass
                else:
                    if run.hints.pot:
                        run.reject(_("""\
The translation coordinator does not trust me enough yet to let me handle
a PO template file all alone.  So, for this one, I'll go disturb him!
"""), "[pot not supported]")
                        abort_robot()
                continue
        # Check if the email was sent to a wrong address.
        if ((to_user and (to_user != 'robot') and (to_user !='translation'))
            or (to_site and (to_site !='translationproject.org'))):
            run.submitter.write(_("""\
I see that you used <%s@%s> to reach me.  Even though it worked,
a few email aliases were surely involved, which are not all under
my control.  It is safer that you use my real email address, which
is <robot@translationproject.org>.
""")
                                         % (to_user, to_site))
        # Clean up translator name.
        if run.translator_name:
            match = re.match('"(.+)"$', run.translator_name)
            if match:
                run.translator_name = match.group(1)

    def mail_body(self, where):
        run.body_lines = open(where).readlines()
        #match = re.match('begin(-base64)? %s (.+?)(\.gz)?$' % uuperm,
        #                 run.body_lines[counter])
        #if match:
        #    base64, temp_name, temp_gzipped = match.group(1, 2, 3)
        #    match = re.search(r'(%s)-(%s)\.(%s)(%s)?\.po$'
        #                      % (registry.DOMAIN, registry.VERSION,
        #                         registry.TEAM, registry.CHARSET), temp_name)
        #    if match:
        #        comment = []
        #        if match.group(1) != run.hints.domain:
        #            comment.append(
        #                '>    the textual domain or package name.\n')
        #        if match.group(2) != run.hints.version:
        #            comment.append(
        #                '>    the version numbers for the package.\n')
        #        if match.group(3) != run.hints.team:
        #            comment.append(
        #                '>    the team two-letter language code.\n')
        #        if match.group(4) != run.hints.charset:
        #            comment.append(
        #                '>    the character set used for translations.\n')
        #        if comment:
        #            run.reject("""\
        #There are inconsistencies between the file from the Subject line of
        #your message, and the uuencoded file name `%s', regarding:
        #
        #%s
        #
        #"""
        #                       % temp_name, string.join(comment, ''))

extract = Extract()


class CheckMail:
    """\
Validating mail specific information.
"""

    def header(self):
        if not (run.translator_address
                and run.hints.domain and run.hints.version and run.hints.team):
            run.reject(_("""\
%s

As a reminder, the Subject line of your message should look like this:

    Subject: TP-robot DOMAIN-VERSION.TEAM.po

The DOMAIN is normally the package name in lower case, VERSION is the
version number of the package, and TEAM is the two-letter lower case
language code for your team.  In some rare cases, TEAM might need to
be suffixed with either "_REGION" or "@DIALECT", where REGION is a
capitalised two-letter country code and DIALECT a lower case name.
""")
                       % unknown_elements_comment(check_translator=1),
                       "[one of address, domain, version, team is missing]")
            abort_robot()

        if run.hints.team:
            globals.team_language = run.hints.team.language
            globals.team_mailto = run.hints.team.mailto[0] or run.translator_address
            globals.team_mailtos = run.hints.team.mailto[:]
        else:
            run.reject(_("""\
Within the Translation Project, there is no team with the code '%s'.
If you simply mistyped the code, I invite you to correct the error
and retry the submission.

If however the code is correct, I presume you would like a new translation
team to be created.  This is a simple matter, really.  See
http://translationproject.org/leaders.html for all the details.
""")
                       % run.hints.team, "[unknown team]")
            globals.team_language = _('Unknown_Language')
            globals.team_mailto = run.translator_address

check_mail = CheckMail()


########################### CheckPoFile #########################
class CheckPoFile:
    """\
Validating the PO file.
"""

    def header(self, header):
        if run.translator_name:
            self.language_team(header)
            self.last_translator(header)
        else:
            self.last_translator(header)
            self.language_team(header)
        self.title(header)
        self.copyright(header)
        self.first_author(header)
        self.project_id_version(header)
        self.both_dates(header)
        self.mime_fields(header)

    def title(self, header):
        if not header['TITLE']:
            run.reject(_("""\
The PO file title comment appears to be missing.  The very first line of
a PO file starts with '#', a space, and then a one-line description of
what this PO file is about.  The PO file title comment may look like:

    # Translation of '%s' messages to %s.

As this line is intended to be read by humans working in %s,
you may have this title line translated as well, it does not have to be
kept in English.
""")
                       % (run.hints.domain,
                          globals.team_language, _(globals.team_language)),
                       "[no title header]")

    def copyright(self, header):
        text = header['COPYRIGHT']
        if isinstance(text, types.ListType):
            # XXX ignore other copyrights
            text = text[0]

        utext = po.decfunc(header)(text)[0]

        match = re.match(
            ('Copyright (\\(C\\)|\xa9|\xc2\xa9).*'
             r' (199[4-9]|200[0-7])(, ((19)?9[4-9]|(20)?0[0-7]))* (?P<author>.*)'),
            text)
        if match:
            # FIXME: Better validate year lists.
            author = 'Free Software Foundation, Inc.'
            definite_author = 0
            if run.hints.domain and run.hints.domain.potcopyright:
                definite_author = 1
                author = run.hints.domain.potcopyright
            if match.group('author') == author:
                return
            if run.hints.domain and \
               (run.hints.domain.disclaim or run.hints.domain.potcopyright):
                if not definite_author:
                    comment = _("""\
For the time being, I merely guess that the Free Software Foundation is to
be listed as the copyright holder for any package requiring translation
disclaimers.  Yet, the truth is that this requirement goes further than
the spirit of the disclaimer.  If this creates any problem in real life,
please write to the translation coordinator, so we can discuss the matter,
and so he could eventually change me (the robot) for handling such cases.
""")
                    reason = "[Copyright not FSF]"
                else:
                    comment = ""
                    reason = "[Copyright not %s]" % author
                                
                run.reject(_("""\
The copyright for the PO file should be assigned to:

    %s

and does not seem to be, yet it might be only a matter of proper spelling.
%s
""")
                           % (author, comment), reason)
        elif run.hints.domain and run.hints.domain.disclaim:
            if text:
                comment = (_("""\
The copyright comment does not seem to be correctly formatted.  I see:

    # %s

while the copyright comment should look like:
""")
                           % utext)
            else:
                comment = _("""\
The copyright comment, which should appear as the second line of the whole
PO file, is apparently missing.  The copyright comment should look like:
""")

            run.reject(_("""\
%s
    # Copyright (C) YEAR Free Software Foundation, Inc.

The '(C)' sign may be replaced by the single Latin-1 character for it
(decimal code 169) if you happen to work in Latin-1, or with the
equivalent UTF-8 seqquence (\\xc2\\xa9).  YEAR is normally a four
digits year, yet it might be a list of years, separated by commas.  In
a list, the first year has to be four digits, subsequent years may be
either two or four digits.  Each comma should be followed with a
space.  Years have to be explicitly enumerated, range notations are
not accepted.
""")
                       % comment, "[copyright incorrectly formatted]")

    def first_author(self, header):
        match = re.search('(.+?)( +)<(.+)>, .*(199[4-9]|200[0-7])',
                          header['AUTHORS'])
        if not match:
            run.reject(_("""\
There is no author comment line in your PO file, or it is not formatted
correctly.  Author lines should come after the copyright lines, and look
like this:

    # AUTHOR <EMAIL@ADDRESS>, YEAR.

There may be several of these lines, normally in chronological order.
"""), "[missing or ill-formatted author line]")
            run.submitter.write(_("""\
If you wish to add some general comments to the PO file, you can put them
after the title, copyright, and author lines.  There should be a space
after the '#' that starts each comment line, and no blank line before
the very first 'msgid' (the empty one).
"""))
            return
        decfunc = po.decfunc(header)
        first_translator, first_address = match.group(1, 3)
        first_translator = decfunc(first_translator)[0]
        if len(match.group(2)) != 1:
            run.submitter.write(_("""\
There is a slight formatting error.  In the initial comment lines,
please use no more than a single space between '%s' and '<%s>'.
""")
                                % (first_translator, first_address))
        try:
            translator = registry.translator(run.hints.team,
                                             first_translator, first_address)
        except KeyError:
            return
        if first_translator != run.translator_name:
            run.submitter.write(_("""\
The last translator of this PO file is not the same as the initial
translator.  This is something quite normal, but if you know that
translators did not change, some more checking is needed.
The third line of whole PO file says '%s', while the 'Last-Translator'
field of the PO file header says '%s'.  If these two names are
misspellings of one another, you should correct whichever is needed and
resubmit the corrected PO file.  On the other hand, I ask you to be fair,
and _never_ remove the initial translator of a given PO file, as this
acknowledgement is the only tribute paid for the work of that translator.
""")
                                % (first_translator, run.translator_name))
        elif first_address != run.translator_address:
            run.submitter.write(_("""\
Your submission contains contradicting addresses for you.  The third
line of the PO file says <%s>, while the 'Last-Translator' field of the
PO file header says <%s>.  Please arrange to have a single preferred
address to reach you, and try to use it consistently in all your
translation files.
""")
                                % (first_address, run.translator_address))

    def project_id_version(self, header):
        match = re.search('(Free |GNU )?(?P<dom>%s)(?P<sep>[- ])(?P<ver>%s)' %
                          (registry.DOMAIN, registry.VERSION),
                          header['project-id-version'])
        if match:
            if match.group('dom') != run.hints.domain.name:
                run.reject(_("""\
The 'Project-Id-Version' field of your PO file says that the textual domain
is '%s', instead of '%s' as the file name says.  They should be the same. 
The domain name is usually just the package name, in all lower case.
""")
                           % (match.group('dom'), run.hints.domain),
                           "[domain from project-id-version conflicts with file name]")
            if match.group('sep') == '-':
                run.submitter.write(_("""\
Within the 'Project-Id-Version' field, the domain name and version numbers
should be separated by a space rather than by a hyphen.  Some scripts might
depend on a space being there, so best would be that you modify your file.
I'll attempt to modify it for you, but just this time! :-)
"""))
                header['project-id-version'] = (
                    header['project-id-version'][:match.start('ver')] + ' '
                    + header['project-id-version'][match.end('ver'):])
            if match.group('ver') != run.hints.version.name:
                run.reject(_("""\
The 'Project-Id-Version' field of your PO file says the translation
is meant for version '%s' of '%s', but the file name says it is for
version '%s'.  Please adjust either the 'Project-Id-Version' field or
the file name, whichever is appropriate.
""")
                           % (match.group('ver'), run.hints.domain.name,
                              run.hints.version.name),
                           "[version from project-id-version conflicts with file name")
        else:
            run.reject(_("""\
The 'Project-Id-Version' field was not found in your PO file header.
The line containing this field ideally looks like:

    'Project-Id-Version: PACKAGE VERSION\\n'

in which PACKAGE should be replaced by the textual domain of your
translation, probably '%s' in this case, and VERSION be replaced
by the appropriate version numbers, maybe '%s' here.
""")
                       % (run.hints.domain.name, run.hints.version.name),
                       "[no project-id-version]")

    def both_dates(self, header):
        reject = 0
        date = {}
        for field in 'POT-Creation-Date', 'PO-Revision-Date':
            value = header[string.lower(field)]
            match = re.match('(199[4-9]|200[0-7])-[01][0-9]-[0-3][0-9] [0-2][0-9]:[0-5][0-9]( ?[-+][0-1][0-9](:?00)?)?',
                             value)
            if match:
                date[field] = value
            else:
                # FIXME: Should use run.reject soon.
                run.submitter.write(_("""\
The '%s' field was not found in your PO file header,
or else it was not formatted properly.  The line containing this field
ideally looks like:

    %s: YEAR-MO-DA HO:MI +ZONE
""")
                                % (field, field))
                if field == 'POT-Creation-Date':
                    run.submitter.write(_("""\
Some older POT files did not have the 'POT-Creation-Date' field.  If
this is the case here, you should not worry, as it will be repaired in
some later release of this package.  This field is not really for the
translator to set.  In the meantime, I will copy the value of the
'PO-Revision-Date' field into it, just to get going.
"""))
                reject = 1
        if reject:
            run.submitter.write(_("""\
In the above line, YEAR is a four-digit number giving the year,
MO is a two-digit number giving the month (from 01 to 12), and DA
is a two-digit number giving the day within the month (from 01 to 31).
The time of the day is provided by a two-digit HO for the hour (from
00 to 23) and a two-digit MI for the minutes (from 00 to 59).

As for +ZONE, it should have the format +HH, -HH, +HH:MM, or -HH:MM.
The '+' sign is used east of Greenwich, the '-' sign west of Greenwich.
HH gives the number of zone hours as two digits (from 00 to 11), while MM,
when used, gives the number of zone minutes.  Other zone notations are
still accepted for the time being, but are to be deprecated.
"""))
        if ((date.has_key('POT-Creation-Date')
             and date.has_key('PO-Revision-Date'))):
            if date['PO-Revision-Date'] <= date['POT-Creation-Date']:
                run.reject(_("""\
The PO revision date is '%s', which looks older than the POT creation date.
You should update the PO revision date before submitting a PO file.
""")
                           % date['PO-Revision-Date'],
                           "[revision date before creation date]")

    def last_translator(self, header):
        decfunc = po.decfunc(header)
        text = header['last-translator']
        match = re.match('(.*?)( +)<(.+)>$', text)
        if match:
            last_translator, last_address = match.group(1, 3)
            last_translator = decfunc(last_translator)[0]  # ignore len
            if len(match.group(2)) != 1:
                run.submitter.write(_("""\
There is a slight formatting error.  In the 'Last-Translator' header line,
please use no more than a single space between '%s' and '<%s>'.
""")
                                             % (last_translator, last_address))
            if not run.translator_name:
                run.translator_name = last_translator
            if not run.translator_address:
                run.translator_address = last_address
            try:
                translator = registry.translator(run.hints.team, last_translator, last_address)
            except KeyError:
                run.reject(_("""\
According to my notes, %s is not a member of the %s team.  If this is only
a matter of spelling, then I need to know about the alternatives, so please
tell the translation coordinator about these.  It is, however, usually best
to avoid such variance, and stick to a single preferred spelling.

It may also be that you never joined the %s team.  Please write to the leader
of your team (see http://translationproject.org/team/index.html for a list,
then go to the relevant team's page), or else to the translation coordinator.
""")
                           % (last_translator,
                              _(globals.team_language),
                              _(globals.team_language)),
                           "[translator not in team]")
                abort_robot()
            if last_address not in translator.mailto:
                if last_address not in globals.reported_unknown:
                    run.reject(_("""\
The last translator of this PO file is %s.  But according to my notes,
<%s> is not a good address to reach that translator.  %s %s
""")
                               % (last_translator, last_address,
                                  say_alias_list(translator.mailto),
                                  globals.unknown_address_insert),
                               "[last address unknown]")
                    globals.reported_unknown.append(last_address)
                    globals.unknown_address_insert = ''
                return
            if (run.translator_name
                and (string.lower(last_translator)
                     != string.lower(run.translator_name))):
                run.submitter.write(_("""\
I'm not fully sure that you are the author of the translations you
sent me.  The header of your email says that you are '%s', while the
'Last-Translator' field of the PO file header says your name is '%s'. 
The difference might be a mere spelling difference.  This can happen
when you do not have full control over your name in the mailing system
you are using.

As I expect you have better control over PO files, I'll consider that
the second name is the most dependable.  Yet, in some cases, this might
represent an error I am unable to analyse, while you do.  In the unlikely
case that the two names above are really different, the situation is more
serious.  Some translation teams surely have their own ways and habits,
but it is unusual that someone submits a translation file written by
someone else.
""")
                                             % (run.translator_name,
                                                last_translator))
            elif (run.translator_address
                  and (string.lower(last_address)
                       != string.lower(run.translator_address))):
                run.submitter.write(_("""\
Your message was sent from '%s', but the 'Last-Translator' field in the
PO file says that your email address is '%s'.  I assume that the latter
is correct.  I bring this to your attention just in case _you_ think it
matters.
""")
                                    % (run.translator_address, last_address))
            run.translator_name = last_translator
            run.translator_address = last_address
        else:
            run.reject(_("""\
The 'Last-Translator' field was not found in your PO file header, or
might not be formatted properly.  The line containing this field ideally
looks like:

    'Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n'

In this line, FULL NAME has to be replaced by the full name of the current
translator for the '%s' textual domain (which most probably means you :-);
EMAIL@ADDRESS gives a way to reach that translator by email.
""")
                       % run.hints.domain, "[last-translator missing]")

    def language_team(self, header):
        text = header['language-team']
        match = re.match('(.+?)( +)<(.+)>$', text)
        if match:
            maybe_language, maybe_mailto = match.group(1, 3)
            try:
                maybe_language.decode('ascii')  # language name should be all ASCII
            except UnicodeError:
                m = []
                for c in maybe_language:
                    if ord(c) < 128: m.append(c)
                    else: m.append('\\%2x' % ord(c))
                maybe_language = ''.join(m)
            if len(match.group(2)) != 1:
                run.submitter.write(_("""\
There is a slight formatting error.  In the 'Language-Team' header line,
please use no more than a single space between '%s' and '<%s>'.
""")
                                    % (maybe_language, maybe_mailto))
            if maybe_language != globals.team_language:
                run.reject(_("""\
You wrote '%s' in the 'Language-Team' field of the PO file header, while
I think it should have been '%s'.  I'm not fully sure about this.  If you
think I got it wrong, please email to the translation coordinator to get
this straigthened this out.
""")
                           % (maybe_language, _(globals.team_language)),
                           "[language-team incorrect]")
            if not globals.team_mailto:
                run.reject(_("""\
Each translation team should publish some mailing list address, meant
to appear (between angular brackets) after the language name in the
'Language-Team' field of the PO file header.  The Translation Project
does not have such an address for the %s team.  You might already know
some list dedicated to internationalisation efforts for %s, which may
fit your needs.  In case you know none, waiting to get better organised,
you might use the address of one of the team members, maybe yours if you
are alone in the team!  In any case, please inform the translation
coordinator of the address your team decides to use.
""")
                           % (_(globals.team_language),
                              _(globals.team_language)),
                           "[team address missing]")
            elif maybe_mailto != globals.team_mailto and \
                     maybe_mailto not in globals.team_mailtos:
                run.reject(_("""\
The 'Language-Team' field of the PO file header contains <%s> as the team's
email adress, but the registered team's address is <%s>.  If this is wrong,
please email the translation coordinator to get it corrected.
""")
                           % (maybe_mailto, globals.team_mailto),
                           "[team address incorrect]")
        else:
            run.reject(_("""\
The 'Language-Team' field was not found in your PO file header, or is
not formatted properly.  The line containing it often looks like:

    'Language-Team: LANGUAGE <TEAM-EMAIL-ADDRESS>\\n'

In this line, LANGUAGE is the English name of your language, capitalizing
the first letter of its words and leaving the rest in lower case.
Sometimes the TEAM-EMAIL-ADDRESS takes the form of
'translation-team-TEAM@lists.sourceforge.net', where TEAM is the ISO-639
code for your language (not to be confused with country codes, which are
a different standard).  If I had to write this line myself, right now,
according to the information which is available to me, I would use:

    'Language-Team: %s <%s>\\n'

If this leaves you clueless and you still want to correct it, please write
to the translation coordinator and we will work this out together.
""")
                       % (globals.team_language, globals.team_mailto),
                       "[language team missing]")

    def mime_fields(self, header):
        if header['mime-version'] != '1.0':
            run.reject(_("""\
The 'MIME-Version' field was not found in your PO file header, or is
not formatted properly.  The line should be this one:

    'MIME-Version: 1.0\\n'
"""),
                       "[mime-version is not 1.0]")
        charsets = [
            'us-ascii',
            'ISO-8859-1',
            'ISO-8859-2',
            'ISO-8859-3',
            'ISO-8859-7',
            'ISO-8859-8',
            'ISO-8859-9',
            'ISO-8859-13',
            'ISO-8859-15',
            'koi8-r',
            'koi8-u',
            'EUC-KR', 'big5', 'big5-hkscs',
            'ISO-2022-JP', 'EUC-JP',
            'gb2312', 'gb18030',
            'UTF-8',
            ]
        match = re.match('text/plain; charset=(.*)', header['content-type'])
        if match:
            charset = match.group(1)
            if string.lower(charset) not in map(string.lower, charsets):
                run.reject(_("""\
The 'Content-Type' field introduced an unusual character set '%s'.
If this is not an error, please merely inform the translation coordinator
that '%s' be added to the list of acceptable charsets.
This list currently holds: %s.
""")
                           % (charset, charset, say_list(_('or'), charsets)),
                           "[unknown charset in content-type]")
            run.po_charset = charset
        else:
            run.reject(_("""\
The 'Content-Type' field was not found in your PO file header, or is
not formatted properly.  The line containing it ideally looks like:

    'Content-Type: text/plain; charset=CHARSET\\n'

where CHARSET should be the name of a character set, like one of %s.
""")
                       % say_list(_('or'), charsets),
                       "[content-type missing or ill-formatted]")
        encodings = ['8-bit', '8bit', 'Base64']
        #   218	8-bit
        #    28	8bit
        #     2	Base64
        cte = header['content-transfer-encoding']
        if cte:
            if cte not in encodings:        # FIXME: ignore case
                run.reject(_("""\
The 'Content-Transfer-Encoding' field introduced an unusual encoding
'%s'.  If this is not an error, please inform the translation
coordinator that '%s' be added to the list of acceptable charsets.
This list currently holds: %s.
""")
                           % (cte, cte, say_list(_('or'), encodings)),
                           "[unknown content-transfer-encoding]")
        else:
            run.reject(_("""\
The 'Content-Transfer-Encoding' field was not found in your PO file header,
or is not formatted properly.  The line containing it ideally looks like:

    'Content-Transfer-Encoding: ENCODING\\n'

where ENCODING should be the name of an encoding, like one of %s.
""")
                       % say_list(_('or'), encodings),
                       "[content-transfer-encoding missing]")

    def scan_gettext_output(self, lines, work, virtual):
        comment = []
        for line in lines:
            if re.match('[0-9]+ translated messages\.$', line):
                continue
            if line[:len(work)] == work:
                line = virtual + line[len(work):]
            comment.append('> %s' % line)
        return comment

    def contents(self, work, virtual, cycle):
        try:
            cmd = 'msgfmt --statistics -c -v -o /dev/null %s'
            proc = popen2.Popen3(cmd % work, 1)
            lines = proc.childerr.readlines()
            reject = proc.wait()
        except:
            run.reject(_("""\
I am unable to run the 'msgfmt' program.  Sorry.  Something needs
to be fixed here.  I'll go warn the translation coordinator.
"""), "[msgfmt failed]")
            abort_robot()
        comment = self.scan_gettext_output(lines, work, virtual)
        if reject:
            run.reject_nofill(_("""\
As a last check, I ran 'msgfmt --statistics -c -v -o /dev/null'
on your PO file.  It told me that I cannot let the file pass.
It reported these errors:
%s""")
                              % ('').join(comment), "[msgfmt errors]")
            abort_robot()
        if comment and (cycle == "first"):
            run.submitter.write_nofill(_("""\
Merely for your information, let me share with you what the
'msgfmt' program has to say about your PO file:
%s""")
                                       % ('').join(comment))

    def special_instructions(self, work):
        if run.hints.domain.name == 'util-linux':
            contents = open(work, 'r').read()
            if contents.find('Permission is granted to freely copy and distribute') == -1:
                run.submitter.write(_("""\
At first sight it seems your translation does not contain a clause that
permits redistribution.  Please consider inserting a sentence like
"""))
                run.submitter.write_nofill("""\
# Permission is granted to freely copy and distribute
# this file and modified versions, provided that this
# header is not removed and modified versions are marked
# as such.
""")
                

check_po_file = CheckPoFile()


########################### CheckRegistry ###########################
class CheckRegistry:
    """\
Processing with the registry of the Translation Project.
"""

    def translator(self):
        team_found = translator_found = domain_found = 0
        try:
            translator = registry.translator(run.hints.team,
                                             run.translator_name,
                                             run.translator_address)
        except KeyError:
            run.reject(_("""\
According to my notes, you are not a member of the %s team. Or at least,
you are not listed there under the name '%s'.  If this is only a matter
of spelling differences, then I need to know exactly which alternate
spellings of your name you use.  Write to the translation coordinator
and explain why you need several different names.  But it is usually
best to avoid such variance, and stick to a single preferred spelling.
""")
                       % (_(globals.team_language), run.translator_name),
                       "[translator not found]")
            return
        if run.translator_address not in translator.mailto:
            if run.translator_address not in globals.reported_unknown:
                run.reject(_("""\
According to my notes, the address <%s> is not a valid way to reach you. 
%s %s
""")
                           % (run.translator_address,
                              say_alias_list(translator.mailto),
                              globals.unknown_address_insert),
                           "[translator address not in registry]")
                globals.reported_unknown.append(run.translator_address)
                globals.unknown_address_insert = ''
        if not run.hints.domain:
            run.reject(_("""\
The '%s' textual domain is not known to the Translation Project, at
least not under that spelling.  It may also be that the maintainer of
that project did not make arrangements yet for the Translation Project to
handle its PO files.  In this case, please invite the project maintainer to
contact us.  See http://translationproject.org/domain/index.html
for the list of domains that are currently handled.
""")
                       % run.hints.domain,
                       "[unknown domain]")
        ok, reason = self.translator_can_submit(translator, run.hints.domain)
        if ok:
            if run.hints.domain.disclaim and not translator.disclaimer:
                run.reject(_("""\
According to my notes, the Free Software Foundation did not acknowledge the
receipt of a translation disclaimer for you.  Such a disclaimer is required
for '%s'.  See http://translationproject.org/html/whydisclaim.html for an
explanantion of this.
""")
                           % run.hints.domain,
                           "[translator has no disclaimer]")
        else:
            run.reject(_("""\
You are not registered as the usual translator for '%s': %s.  If you wish
to be assigned to this textual domain, your team leader may send an email
to the translation coordinator warranting that you are indeed assigned.
""")
                       % (run.hints.domain, reason[1:-1]), reason)

    def have_pot(self):
        if not os.path.isfile(run.hints.template_path()):
            run.reject(_("""\
You submitted a PO file for which the Translation Project does not have a
corresponding template: there is no '%s' here.
Please have the maintainer of the package send the corresponding POT file
to the Translation Project.  Or better: a URL of a distribution tarball.
""")
                       % run.hints.template_base(),
                       "[there is no corresponding pot file]")
            return 0
        return 1

    def preexisting(self, work):
        if registry.compare_files(work, run.hints.archive_path()):
            comment = [_("""
The Translation Project already holds an exact copy of your submission,
which you may find as:
""")]
            comment.append('    %s\n' % run.hints.archive_url())
            run.reject_nofill(('').join(comment), "[duplicate submission]")

    def translator_can_submit(self, translator, domain):
        # If it is the assigned translator, accept.
        if domain in translator.do:
            return 1, "[translator is assigned]"
        # If somebody else is assigned, reject.
        if run.hints.team.translator_for_domain(domain):
            return 0, "[someone else is assigned to this domain]"
        # If there is an external translation, reject.
        if run.hints.team.code in domain.ext:
            return 0, "[the domain is externally translated]"
        # If there is no preexisting translation, accept.
        #! This checking of a symlink is not foolproof, as there are some files
        #! for which this symlink is missing or pointing to an old version.
        file = run.hints.maintainer_path()
        if not os.path.exists(file):
            return 1, "[first submission to this domain]"
        # If it exists, find its submitter, the "last maker".
        import data
        stats = data.load_postats()
        hints = registry.Hints(os.readlink(file))
        try:
            st = stats[(hints.domain.name, hints.version.name, hints.team.name)]
            last_maker, email = st[0], st[1]
        except KeyError:
            # Stats not updated yet, need to read PO file.
            content = po.read(file)
            last_maker, email = po.last_translator(po.header(content))
        try:
            last_maker = registry.translator(hints.team, last_maker, email)
        except KeyError:
            return 0, "[unknown translator]"
        # If the current submitter equals the last maker, accept.
        if translator == last_maker:
            return 1, "[translator equals last translator]"
        else:
            return 0, "[someone else made the last submission]"

check_registry = CheckRegistry()


class Process:
    """\
Accomplishing actions.  In fact, putting here whatever does not fit elsewhere.
"""

    def make_canonical(self, where, virtual, entries, header):
        os.system('recode -f /cl <%s | msgmerge -q --no-wrap - %s >%s.norm'
                  % (where, run.hints.template_path(), where))
        try:
            lines = os.popen('recode -f /cl <%s | diff -u -L %s~ -L %s - %s.norm'
                             % (where, virtual, virtual, where)).readlines()
        except:
            run.reject(_("""\
I am unable to run the 'diff' program.  Sorry.  Something needs
to be fixed here.  I'll go warn the translation coordinator.
"""), "[diff or recode failed]")
            abort_robot()
        # FIXME: Maybe detect and better explain `msgid' reformatting, trailing
        # space elimination, and other less evident matters.
        try:
            os.remove(where)
            os.rename('%s.norm' % where, where)
        except:
            run.reject(_("""\
I am unable to canonicalise your PO file.  Sorry.  Something needs
to be fixed here.  I'll go warn the translation coordinator.
"""), "[remove or rename failed]")
            abort_robot()
        if lines:
            if len(lines) > 50:
                lines = lines[:50] + ["[truncated]\n"]
            run.submitter.write(_("""\
The Translation Project is trying to reach a consistent presentation for
PO files, over all domains and languages.  Your submission was not fully
canonical, so the robot has made the following modifications to your PO
file.  You can use 'patch' to apply these changes to your local file,
but you do not need to: the robot will continue making them patiently and
automatically here.  This message continues after the (maybe long) diff.
"""))
            # Possibly non-ASCII byte strings, don't try to translate.
            run.submitter.write_nofill("""\
---------------------------------------------------------------------->
%s----------------------------------------------------------------------<
"""
                                  % ''.join(lines))

    def congratulate(self):
        run.subject = 'TP: %s [ACCEPTED]' % run.shorten(run.subject)
        run.submitter.write(_("""\
Your file has been accepted and stored in the archives.  Thank you!

When the maintainer of '%s' submits a new POT file to the Translation
Project, the translation you just made will probably need revision.  Your
team will then be notified of the URL of the PO file to revise, together
with a quick valuation of the extent of the work needed.
""")
                            % run.hints.domain.name)
        try:
            translator = registry.translator(run.hints.team,
                                             run.translator_name,
                                             run.translator_address)
        except KeyError:
            pass
        else:
            if not translator.autosend:
                run.submitter.write(_("""\
To speed things up, I could send you an updated copy of this PO file
by email whenever a new template file for it arrives.  If you are
interested in this service, you can ask for it by emailing to the
translation coordinator.
"""))

    def upload_po_file(self, work_name):
        archive_base = run.hints.archive_base()
        incoming = '%s/%s' % (config.temp_path, archive_base)
        # Remove any file left over from a previous try in dry mode.
        if os.path.isfile(incoming):
            os.remove(incoming)
        shutil.move(work_name, incoming)
        try:
            if run.dry:
                dry_flag = '-n'
            else:
                dry_flag = ''
            lines = os.popen(
                'cd %s && %s/bin/po-register %s %s 2>&1'
                % (config.temp_path, config.progs_path, dry_flag, archive_base)
                ).readlines()
        except:
            run.reject(_("""\
I am unable to run the 'po-register' program.  Sorry.  Something needs
to be fixed here.  I'll go warn the translation coordinator.
"""), "[po-register failed]")
            return
        comment = []
        write = comment.append
        if run.header_lines:
            write(_('Original message header:\n'))
            write('\n')
            for line in run.header_lines:
                write('>    ' + line)
            write('\n')
        write(_('Diagnostics issued by \'po-register\':\n'))
        write('\n')
        for line in lines:
            write('>    ' + line)
        run.coordinator.write_nofill(('').join(comment))

process = Process()


## Diagnostics.

def unknown_elements_comment(check_translator=0):
    known = []
    unknown = []
    if check_translator:
        if run.translator_address:
            known.append(_("the translators's address is '%s'")
                         % run.translator_address)
        else:
            unknown.append(_("the translator's address"))
    if run.hints.domain:
        known.append(_("the textual domain is '%s'") % run.hints.domain)
    else:
        unknown.append(_("the textual domain"))
    if run.hints.version:
        known.append(_("the domain version is '%s'") % run.hints.version)
    else:
        unknown.append(_("the domain version"))
    if run.hints.team:
        known.append(_("the team code is '%s'" % run.hints.team))
    else:
        unknown.append(_("the team code"))
    if known:
        return ("There is information missing from your message header: %s."
                "  I did find that %s."
                % (say_list(_('and'), unknown), say_list(_('and'), known)))
    return "Information that is missing: %s." % say_list(_('and'), unknown)

def say_alias_list(items):
    if len(items) == 0:
        return _("""\
No official email address is registered for this translator.
""")
    if len(items) == 1:
        return (_("""\
The only registered address for this translator is <%s>.
""")
                % items[0])
    aliases = items[:]
    aliases.sort()
    return (_("""\
The only registered addresses for this translator are: %s.
""")
            % say_list(_('and'), aliases))

def say_list(word, items):
    if len(items) == 0:
        return 'none'
    if len(items) == 1:
        return items[0]
    return '%s %s %s' % ((', ').join(items[:-1]), word, items[-1])


ecre = re.compile(r'''
  =\?                   # literal =?
  (?P<charset>[^?]*?)   # non-greedy up to the next ? is the charset
  \?                    # literal ?
  (?P<encoding>[qb])    # either a "q" or a "b", case insensitive
  \?                    # literal ?
  (?P<atom>.*?)         # non-greedy up to the next ?= is the atom
  \?=                   # literal ?=
  ''', re.VERBOSE | re.IGNORECASE)

#from email.Utils.decode
def mime_decode_header(h):
    rtn = []
    parts = ecre.split(h, 1)
    while parts:
        # If there are less than 4 parts, it can't be encoded and we're done.
        if len(parts) < 5:
            rtn.extend(parts)
            break
        # The first element is any non-encoded leading text.
        rtn.append(parts[0])
        charset = parts[1]
        encoding = parts[2].lower()
        atom = parts[3].replace('_', ' ')
        # The next chunk to decode should be in parts[4].
        parts = ecre.split(parts[4])
        # The encoding must be either 'q' or 'b', case-insensitive.
        if encoding == 'q':
            func = _qdecodestring
        else:
            # XXX base64 not supported.
            return h
        try:
            # Decode and get the unicode in the charset.
            rtn.append(unicode(func(atom), charset))
        except:
            return h
    # Now that we've decoded everything, we just need to join all the parts
    # together into the final string.
    try:
        return u"".join(rtn)
    except UnicodeError:
        # Some of the ASCII parts contain characters above 128;
        # assume they are Latin-1.
        for i in range(len(rtn)):
            if type(rtn[i])==types.StringType:
                rtn[i] = unicode(rtn[i], "iso-8859-1")
        return u"".join(rtn)

if __name__ == '__main__':
    apply(main, tuple(sys.argv[1:]))
    #try:
    #    apply(main, tuple(sys.argv[1:]))
    #except AbortRobot:
    #    sys.exit(1)
